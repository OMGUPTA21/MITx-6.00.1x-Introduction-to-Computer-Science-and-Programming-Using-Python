Problem 1
Midterm due Sep 30, 2020 05:00 IST
Completed
 Bookmark this page
Problem 1-1
1.0/1.0 point (graded)
Suppose x = "pi" and y = "pie". The line of code x, y = y, x will swap the values of x and y, resulting in x = "pie" and y = "pi".


True*
False
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 1-2
1.0/1.0 point (graded)
Suppose x is an integer in the following code:
def f(x):
    while x > 3:
        f(x+1)

For any value of x, all calls to f are guaranteed to never terminate.

True
False*
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 1-3
1.0/1.0 point (graded)
A Python program always executes every line of code written at least once.


True
False*
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 1-4
1.0/1.0 point (graded)
Suppose you have two different functions that each assign a variable called x. Modifying x in one function means you always modify x in the other function for any x.


True
False*
correct
Problem 1-5
1.0/1.0 point (graded)
The following code will enter an infinite loop for all values of i and j.

while i >= 0:
    while j >= 0:
        print(i, j)

True
False*
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 1-6
1.0/1.0 point (graded)
It is always possible and feasible for a programmer to come up with test cases that run through every possible path in a program.


True
False*
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 1-7
1.0/1.0 point (graded)
Assume f() is defined. In the statement a = f(), a is always a function.


True
False*
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 1-8
1.0/1.0 point (graded)
A program that keeps running and does not stop is an example of a syntax error.


True
False*
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 1-9
1.0/1.0 point (graded)
Consider the following function.
def f(x):
    a = []
    while x > 0:
        a.append(x)
        f(x-1)

A new object of type list is created for each recursive invocation of f.

True*
False
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 1-10
1.0/1.0 point (graded)
A tuple can contain a list as an element.


True*
False
correct
Submit
Problem 2
Midterm due Sep 30, 2020 05:00 IST
Completed
 Bookmark this page
Problem 2-1
1.0/1.0 point (graded)
Consider the statement: L = {'1':1, '2':2, '3':3}. Which is correct?


L is a list
L is immutable
L contains 6 elements
L has integer keys
L maps strings to integers*
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 2-2
1.0/1.0 point (graded)
Assume a break statement is executed inside a loop and that the loop is inside a function. Which of the following is correct?


The program might immediately terminate.
The function might immediately terminate.
The loop will always immediately terminate.
All of the above.*
None of the above.
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 2-3
1.0/1.0 point (graded)
In Python, which of the following is a mutable object?


a string
a tuple
a list*
all of the above
none of the above
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 2-4
1.0/1.0 point (graded)
Assume the statement s[1024] = 3 does not produce an error message. This implies:


type(s) can be str
type(s) can be tuple
type(s) can be list*
All of the above
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 2-5
1.0/1.0 point (graded)
Consider the code:

L = [1,2,3]
d = {'a': 'b'}
def f(x):
    return 3
Which of the following does NOT cause an exception to be thrown?


print(L[3])
print(d['b'])

for i in range(1000001, -1, -2):*
    print(f)
print(int('abc'))
None of the above
correct
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 2-6
0.0/3.0 points (graded)
Examine the following code snippet:

  stuff  = _____
  for thing in stuff:
        if thing == 'iQ':
           print("Found it")
Select all the values of the variable "stuff" that will make the code print "Found it".


["iBoy", "iGirl", "iQ", "iC","iPaid","iPad"]*
("iBoy", "iGirl", "iQ", "iC","iPaid","iPad")
[ ( "iBoy", "iGirl", "iQ", "iC","iPaid","iPad") ]*
( [ "iBoy", "iGirl", "iQ", "iC","iPaid","iPad" ], )
["iQ"]
"iQ"
incorrect
SubmitYou have used 1 of 1 attemptSome problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Problem 2-7
2.0/2.0 points (graded)
The following Python code is supposed to compute the square of an integer by using successive additions.

def Square(x):
    return SquareHelper(abs(x), abs(x))

def SquareHelper(n, x):
    if n == 0:
        return 0
    return SquareHelper(n-1, x) + x
Not considering recursion depth limitations, what is wrong with this implementation of procedure Square? Check all that apply.


It is going to return a wrong value.
The term Square is a reserved Python keyword.
Function names cannot start with a capital letter.
The function is never going to return anything.
Python has arbitrary precision arithmetic.
This function will not work for negative numbers.
The call SquareHelper(abs(x), abs(x)) won't work because you can't have abs(x) as both parameters.
Nothing is wrong; the code is fine as-is.*
Problem 3
10.0/10.0 points (graded)
Implement a function called closest_power that meets the specifications below.

def closest_power(base, num):
    '''
    base: base of the exponential, integer > 1
    num: number you want to be closest to, integer > 0
    Find the integer exponent such that base**exponent is closest to num.
    Note that the base**exponent may be either greater or smaller than num.
    In case of a tie, return the smaller value.
    Returns the exponent.
    '''
    # Your code here
For example,

closest_power(3,12) returns 2
closest_power(4,12) returns 2
closest_power(4,1) returns 0
Paste your entire function, including the definition, in the box below. Do not leave any debugging print statements.
solution
# Problem 4
# 10/10 points (graded)
# Implement a function called closest_power that meets the specifications below.

# def closest_power(base, num):
#     '''
#     base: base of the exponential, integer > 1
#     num: number you want to be closest to, integer > 0
#     Find the integer exponent such that base**exponent is closest to num.
#     Note that the base**exponent may be either greater or smaller than num.
#     In case of a tie, return the smaller value.
#     Returns the exponent.
#     '''
#     # Your code here

#For example,
# closest_power(3,12) returns 2
# closest_power(4,12) returns 2
# closest_power(4,1) returns 0

 

# Paste your function here
def closest_power(base, num):
    result = 0
    if base > num:
        result = 0
    elif base == num:
        result = 1
    else:
        for i in range(1, int(num)):
            if abs(base**i - num) <= abs(base**(i + 1) - num):
                result = i
                break
    return result
Problem 4
15.0/15.0 points (graded)
Write a function called getSublists, which takes as parameters a list of integers named L and an integer named n.

assume L is not empty
assume 0 < n <= len(L)
This function returns a list of all possible sublists in L of length n without skipping elements in L. The sublists in the returned list should be ordered in the way they appear in L, with those sublists starting from a smaller index being at the front of the list.

Example 1, if L = [10, 4, 6, 8, 3, 4, 5, 7, 7, 2] and n = 4 then your function should return the list [[10, 4, 6, 8], [4, 6, 8, 3], [6, 8, 3, 4], [8, 3, 4, 5], [3, 4, 5, 7], [4, 5, 7, 7], [5, 7, 7, 2]]

Example 2, if L = [1, 1, 1, 1, 4] and n = 2 then your function should return the list [[1, 1], [1, 1], [1, 1], [1, 4]]


Your function does not have to be recursive. Do not leave any debugging print statements when you paste your code in the box.
"""
Write a function called getSublists, which takes as parameters a list of integers named L 
and an integer named n.
assume L is not empty
assume 0 < n <= len(L)
This function returns a list of all possible sublists in L of length n without skipping 
elements in L. The sublists in the returned list should be ordered in the way they appear 
in L, with those sublists starting from a smaller index being at the front of the list.
Example 1, if L = [10, 4, 6, 8, 3, 4, 5, 7, 7, 2] and n = 4 then your function should 
return the list [[10, 4, 6, 8], [4, 6, 8, 3], [6, 8, 3, 4], [8, 3, 4, 5], [3, 4, 5, 7], 
[4, 5, 7, 7], [5, 7, 7, 2]]
Example 2, if L = [1, 1, 1, 1, 4] and n = 2 then your function should return the list 
[[1, 1], [1, 1], [1, 1], [1, 4]]
"""

def getSublists(L, n):
	list_of_sublists = [] 	
	for i in range(len(L)-n+1):
		list_of_sublists.append(L[i:i+n]) 
		#create sublists of length n for every i and adds this sublist to master sublist
	return list_of_sublists

"""
Write a function called longestRun, which takes as a parameter a list of integers named L 
(assume L is not empty). This function returns the length of the longest run of 
monotonically increasing numbers occurring in L. A run of monotonically increasing 
numbers means that a number at position k+1 in the sequence is either greater than or 
equal to the number at position k in the sequence.
For example, if L = [10, 4, 6, 8, 3, 4, 5, 7, 7, 2] then your function should return the 
value 5 because the longest run of monotonically increasing integers 
in L is [3, 4, 5, 7, 7].
My function creates a list of sublists for i ranging from the length of the list L 
down to 0.
It then loops through those lists and checks to see if any of those lists are monotonic.
If so, the function returns the current value of i, the Longest Run.
"""

def longestRun(L):
	for i in range(len(L),0,-1): 	
		for list in getSublists(L,i): 
			if all(x<=y for x, y in zip(list, list[1:])) == True: #checks to see if list is monotonic
				return i
		Problem 5
20.0/20.0 points (graded)
Write a Python function that returns a list of keys in aDict with the value target. The list of keys you return should be sorted in increasing order. The keys and values in aDict are both integers. (If aDict does not contain the value target, you should return an empty list.)

This function takes in a dictionary and an integer and returns a list.
##This function takes in a dictionary and an integer and returns a list.
solution
def keysWithValue(aDict, target):
    '''
    aDict: a dictionary
    target: an integer
    '''
    # Your code here 
    values = aDict.values()
    keysList = []
    if target in values:
        for i in aDict.keys():

            if aDict[i] == target:
                keysList.append(i)

                keysList.sort()

        return keysList
    else:
        return []
print keysWithValue({56:23,2:32,20:34,4:59,5:23,6:23,7:23},23)
Problem 6
20.0/20.0 points (graded)
Write a function to flatten a list. The list contains other lists, strings, or ints. For example, [[1,'a',['cat'],2],[[[3]],'dog'],4,5] is flattened into [1,'a','cat',2,3,'dog',4,5] (order matters).
# Paste your function here
solution
def flatten(aList):
    newList = []
    for item in aList:
        if type(item) != type([]):
            newList.append(item)
        else:
            newList.extend(flatten(item))
    return newList
Problem 7
20.0/20.0 points (graded)
Write a function called score that meets the specifications below.

def score(word, f):
    """
       word, a string of length > 1 of alphabetical 
             characters (upper and lowercase)
       f, a function that takes in two int arguments and returns an int

       Returns the score of word as defined by the method:

    1) Score for each letter is its location in the alphabet (a=1 ... z=26) 
       times its distance from start of word.  
       Ex. the scores for the letters in 'adD' are 1*0, 4*1, and 4*2.
    2) The score for a word is the result of applying f to the
       scores of the word's two highest scoring letters. 
       The first parameter to f is the highest letter score, 
       and the second parameter is the second highest letter score.
       Ex. If f returns the sum of its arguments, then the 
           score for 'adD' is 12 
    """
    #YOUR CODE HERE
Paste your entire function, including the definition, in the box below. Do not leave any print statements.
solution
# Paste your code here
def score(word, f):
    """
       word, a string of length > 1 of alphabetical
             characters (upper and lowercase)
       f, a function that takes in two int arguments and returns an int
       Returns the score of word as defined by the method:
    1) Score for each letter is its location in the alphabet (a=1 ... z=26)
       times its distance from start of word.
       Ex. the scores for the letters in 'adD' are 1*0, 4*1, and 4*2.
    2) The score for a word is the result of applying f to the
       scores of the word's two highest scoring letters.
       The first parameter to f is the highest letter score,
       and the second parameter is the second highest letter score.
       Ex. If f returns the sum of its arguments, then the
           score for 'adD' is 12
    """
    scoreList=[]    #contains list of score of individual word
    for index in range(len(word)):
        char = word[index].upper()
        score = index * (ord(char)%64)          #using ascii code for getting a=1, b=2 ....
        scoreList.append(score)
    scoreList.sort(reverse=True)                #the 1st 2 elements of list have highest score
    return f(scoreList[0],scoreList[1])
    
